// Weekly Data Refresh Scheduler
// Automatically collects new social media data and updates the dashboard

const fs = require('fs');
const path = require('path');
const { SocialMediaDataCollector, FacebookAPIService } = require('./social-media-apis');
const { processSocialData } = require('./data-processor');

// Configuration
const CONFIG = {
  markets: ['france', 'italy', 'germany', 'global'],
  dataDirectory: path.join(__dirname, '../src/data'),
  backupDirectory: path.join(__dirname, '../data/backups'),
  logFile: path.join(__dirname, '../logs/refresh.log'),
  maxBackups: 10
};

/**
 * Main refresh function
 */
async function runWeeklyRefresh() {
  console.log('üöÄ Starting weekly social media data refresh...');
  logMessage('Starting weekly refresh');

  try {
    // Create backup of current data
    await createBackup();

    // Collect and process data for each market
    const collector = new SocialMediaDataCollector();
    const allMarketData = {};

    for (const market of CONFIG.markets) {
      console.log(`üìä Processing market: ${market}`);
      logMessage(`Processing market: ${market}`);

      try {
        const processedData = await collector.collectAndProcess(market);
        allMarketData[market] = processedData;

        console.log(`‚úÖ Completed market: ${market} (${processedData.consumerQuotes?.length || 0} quotes)`);
        logMessage(`Completed market: ${market} (${processedData.consumerQuotes?.length || 0} quotes)`);
      } catch (error) {
        console.error(`‚ùå Failed to process market ${market}:`, error.message);
        logMessage(`ERROR: Failed to process market ${market}: ${error.message}`);
      }

      // Small delay between markets to be respectful to APIs
      await new Promise(resolve => setTimeout(resolve, 5000));
    }

    // Update the main data file
    updateMainDataFile(allMarketData);

    console.log('‚úÖ Weekly refresh completed successfully!');
    logMessage('Weekly refresh completed successfully');

    // Clean up old backups
    await cleanupOldBackups();

  } catch (error) {
    console.error('‚ùå Weekly refresh failed:', error.message);
    logMessage(`ERROR: Weekly refresh failed: ${error.message}`);
    throw error;
  }
}

/**
 * Create backup of current data
 */
async function createBackup() {
  const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
  const backupFilename = `r12gsConsumerData_backup_${timestamp}.js`;
  const backupPath = path.join(CONFIG.backupDirectory, backupFilename);

  // Ensure backup directory exists
  if (!fs.existsSync(CONFIG.backupDirectory)) {
    fs.mkdirSync(CONFIG.backupDirectory, { recursive: true });
  }

  // Copy current data file
  const currentDataPath = path.join(CONFIG.dataDirectory, 'r12gsConsumerData.js');
  if (fs.existsSync(currentDataPath)) {
    fs.copyFileSync(currentDataPath, backupPath);
    console.log(`üíæ Backup created: ${backupFilename}`);
    logMessage(`Backup created: ${backupFilename}`);
  }
}

/**
 * Update the main data file with new data
 */
function updateMainDataFile(marketData) {
  const dataFilePath = path.join(CONFIG.dataDirectory, 'r12gsConsumerData.js');

  // Generate the JavaScript export
  const jsContent = `// This file is auto-generated by weekly-refresh.js
// Last updated: ${new Date().toISOString()}
// Data source: Social Media APIs

export const r12gsConsumerData = ${JSON.stringify(marketData, null, 2)};
`;

  // Write the file
  fs.writeFileSync(dataFilePath, jsContent);
  console.log(`üìù Updated main data file: ${dataFilePath}`);
  logMessage(`Updated main data file with ${Object.keys(marketData).length} markets`);
}

/**
 * Clean up old backup files
 */
async function cleanupOldBackups() {
  try {
    const backupFiles = fs.readdirSync(CONFIG.backupDirectory)
      .filter(file => file.startsWith('r12gsConsumerData_backup_'))
      .sort()
      .reverse(); // Most recent first

    if (backupFiles.length > CONFIG.maxBackups) {
      const filesToDelete = backupFiles.slice(CONFIG.maxBackups);

      for (const file of filesToDelete) {
        const filePath = path.join(CONFIG.backupDirectory, file);
        fs.unlinkSync(filePath);
        console.log(`üóëÔ∏è Deleted old backup: ${file}`);
      }

      logMessage(`Cleaned up ${filesToDelete.length} old backups`);
    }
  } catch (error) {
    console.warn('Warning: Could not cleanup old backups:', error.message);
  }
}

/**
 * Log message to file and console
 */
function logMessage(message) {
  const timestamp = new Date().toISOString();
  const logEntry = `[${timestamp}] ${message}\n`;

  // Ensure logs directory exists
  const logsDir = path.dirname(CONFIG.logFile);
  if (!fs.existsSync(logsDir)) {
    fs.mkdirSync(logsDir, { recursive: true });
  }

  // Append to log file
  fs.appendFileSync(CONFIG.logFile, logEntry);
}

/**
 * Get last refresh timestamp
 */
function getLastRefreshTime() {
  try {
    if (!fs.existsSync(CONFIG.logFile)) return null;

    const logs = fs.readFileSync(CONFIG.logFile, 'utf8');
    const lines = logs.trim().split('\n');
    const lastLine = lines[lines.length - 1];

    if (lastLine && lastLine.includes('Weekly refresh completed successfully')) {
      const timestamp = lastLine.match(/\[([^\]]+)\]/)?.[1];
      return timestamp ? new Date(timestamp) : null;
    }
  } catch (error) {
    console.warn('Could not read last refresh time:', error.message);
  }
  return null;
}

/**
 * Check if refresh is needed (weekly schedule)
 */
function shouldRunRefresh() {
  const lastRefresh = getLastRefreshTime();

  if (!lastRefresh) {
    console.log('No previous refresh found, running initial refresh');
    return true;
  }

  const now = new Date();
  const daysSinceLastRefresh = (now - lastRefresh) / (1000 * 60 * 60 * 24);

  if (daysSinceLastRefresh >= 7) {
    console.log(`Last refresh was ${Math.round(daysSinceLastRefresh)} days ago, running refresh`);
    return true;
  }

  console.log(`Last refresh was ${Math.round(daysSinceLastRefresh)} days ago, skipping`);
  return false;
}

// Export functions for testing
module.exports = {
  runWeeklyRefresh,
  shouldRunRefresh,
  getLastRefreshTime,
  createBackup,
  updateMainDataFile
};

// CLI usage
if (require.main === module) {
  const args = process.argv.slice(2);

  if (args.includes('--force')) {
    console.log('üîß Force refresh requested');
    runWeeklyRefresh().catch(console.error);
  } else if (args.includes('--check')) {
    const lastRefresh = getLastRefreshTime();
    console.log('Last refresh:', lastRefresh || 'Never');
    console.log('Should run:', shouldRunRefresh());
  } else if (args.includes('--status')) {
    const lastRefresh = getLastRefreshTime();
    const daysSince = lastRefresh ? (new Date() - lastRefresh) / (1000 * 60 * 60 * 24) : 'Never';
    console.log('Refresh Status:');
    console.log(`- Last refresh: ${lastRefresh || 'Never'}`);
    console.log(`- Days since: ${typeof daysSince === 'number' ? Math.round(daysSince) : daysSince}`);
    console.log(`- Should run: ${shouldRunRefresh()}`);
  } else {
    // Normal scheduled run
    if (shouldRunRefresh()) {
      runWeeklyRefresh().catch(console.error);
    } else {
      console.log('‚è∞ Not time for refresh yet');
    }
  }
}
